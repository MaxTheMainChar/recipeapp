# RecipeApp – Project Guidelines

## 1. Product vision

RecipeApp helps users turn whatever ingredients they have on hand into practical recipes in seconds.

- **Primary user flow**: Enter ingredients → Click one primary CTA → Get 2–5 recipes.
- **Target feeling**: “I can quickly decide what to cook without scrolling through blogs or thinking too much.”
- **Initial target users (MVP)**: People with random leftovers or limited time (students / busy people).

---

## 2. Core user flow

1. User lands on the main page.
2. User adds ingredients (free text or chip-style input).
3. User clicks the primary button: **“Generate recipes”**.
4. App calls AI backend to generate recipes.
5. App displays 2–5 recipes in a clean, readable format.

### Each recipe should show

- Title
- Short description (optional, 1–2 sentences)
- Ingredients (list)
- Steps (ordered list)
- Prep / cook time (e.g., `prepTimeMinutes`)
- Difficulty (e.g., `easy | medium | hard`)
- Optional: estimated calories / rough nutrition info
- Optional: tags (e.g., `high protein`, `vegetarian`, `15-minute`)

---

## 3. Tech stack

- **Frontend**: React SPA
  - Some components generated by **v0** – don’t fight them, extend them.
- **Backend**: Node-based (or framework of choice) calling an OpenAI-compatible API.
- **AI**: GPT-style model that accepts prompt + ingredients and returns structured recipe data.
- **Deployment**: Any simple cloud host (e.g., Vercel/Netlify/Render).

Stay consistent with the existing stack used in the repo (TypeScript vs JavaScript, Tailwind vs other styling, etc.).

---

## 4. Architecture

### Frontend structure (suggested)

- `src/pages/`
  - `Home` (ingredients input + results view)
- `src/components/`
  - `IngredientInput` – handles adding/removing ingredients
  - `GenerateButton` – main CTA
  - `RecipeList` – wraps list of recipes
  - `RecipeCard` – displays a single recipe
  - `LoadingState`, `ErrorState`, `EmptyState` components
- `src/api/`
  - `apiClient` – functions to call backend endpoints

### Backend structure (suggested)

- `routes/` or `api/`
  - `POST /api/generate-recipes`
    - Request body:  
      ```json
      {
        "ingredients": ["egg", "tomato", "cheese"],
        "constraints": {
          "maxRecipes": 5,
          "diet": "any",
          "maxTimeMinutes": 30
        }
      }
      ```
    - Response body:
      ```json
      {
        "recipes": [
          {
            "id": "string",
            "title": "string",
            "description": "string",
            "ingredients": ["string"],
            "steps": ["string"],
            "prepTimeMinutes": 20,
            "difficulty": "easy",
            "estimatedCalories": 550,
            "tags": ["high protein", "quick"]
          }
        ]
      }
      ```

---

## 5. UX & UI guidelines

- **Above the fold**:
  - Clear headline: what the app does in one sentence.
  - Short subtext.
  - Ingredient input + main button visible without scrolling.
- **Single primary action**:
  - Only one dominant CTA: “Generate recipes”.
- **States to handle**:
  - **Initial**: Instructional placeholder text.
  - **Loading**: Spinner / skeleton + “Generating recipes…”.
  - **Success**: Recipe list.
  - **Empty response / weak results**: Friendly message with suggestion to tweak ingredients.
  - **Error**: Simple message + “Try again” option.
- **Copy tone**:
  - Friendly, short, non-technical.
  - Example: “Type what you have: ‘chicken, rice, onion…’”.

---

## 6. Code style guidelines

- Use **function components** and **hooks** (no class components).
- Prefer **composition** over giant components.
- Use consistent naming:
  - Components: `PascalCase` (`RecipeCard`).
  - Functions/variables: `camelCase` (`generateRecipes`, `ingredientsList`).
- Handle async logic with `async/await`.
- Validate API responses minimally:
  - Check for `recipes` array.
  - Guard against `null` or unexpected shapes.
- Keep business logic separate from presentation when reasonable:
  - Formatting helpers (e.g., `formatMinutesToLabel`) should live in utility modules.

---

## 7. AI & prompt guidelines

- The backend should:
  - Instruct the model to **return structured JSON** matching the `recipes[]` schema.
  - Emphasize practicality: normal ingredients, clear steps, realistic times.
  - Avoid unsafe instructions (e.g., raw meat handling shortcuts).
- Always:
  - Parse model output safely; fall back to friendly error if parsing fails.
  - Log errors on the server side (without leaking secrets or user-specific data).

---

## 8. Environment variables & secrets

- Never commit secrets.
- Read keys from environment variables, e.g.:
  - `OPENAI_API_KEY`
  - `RECIPEAPP_API_BASE_URL`
- Document required env vars in a `.env.example` file.

Example `.env.example` snippet:

```bash
OPENAI_API_KEY=your-key-here
RECIPEAPP_API_BASE_URL=http://localhost:3000